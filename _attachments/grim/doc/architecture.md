### The HTTPLocal Architecture

HTTPLocal answers a number of questions for app coordination. For one, it establishes a program model-- the stateless server and its detached clients. Even though the Local servers are on the client-side, they are still, philosophically, web-servers; they never bind directly to the client. Thus, the DOM API's absence in Workers is not a problem. The model does require some additions to DOM behavior so that applications can behave richly, but this is easy to do through the environment document (it merely binds new behaviors across the page). Current behaviors include support for real-time UI updates, and, while it is limited compared to direct DOM access, it should cover a broad set of needs.

Composition is made possible in this architecture, built largely around message formation and routing. This can be managed at runtime with tools like unix's CLI pipe, or with existing Web interfaces like links and forms. (Because links and forms are able to target 'httpl://' servers, no explicit event-binding is required. This tends to simplify interface construction.)

A common use-case for apps is to act as proxies to data services. For instance, this documentation is written in markdown, and a Local markdown-to-html proxy serves them to the page. (You should be able to see the requests to v1.pfraze.markdown.convert.app in the log to your right.)

For programmatic interfaces, Local uses the Link header, which simplifies the task of finding the links (compared to searching the response body). Using rel attributes as a primary description, title attributes as names, and URI templates, services are able export APIs which clients navigate without too much out-of-band knowledge. Rather than construct a URI, the client will, for example, open a navigator to the service, navigate to a collection, navigate to an item, and issue a request. The client could feasibly swap out the provider so long as the replacement offers equivalent links.

The Server-Sent Events protocol has been built into the HTTPL API so programs are able to request subscriptions to each other. This is useful for maintaining sync across detached components, and for pushing realtime updates from a service out to its clients. In fact, one custom DOM behavior is a directive which subscribes the element to an app's SSEs, allowing the server to command UI refreshes.

Security decisions are made based on request origin and the features of the request. The environment intermediates all requests made, so it is able to do any routing, logging, or denial it deems necessary. Sessions with remote services are managed there, and policies should be carefully constructed to keep credentials from ever leaking back into the apps.